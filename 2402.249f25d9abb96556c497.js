"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[2402],{2402:function(a,e,d){d.r(e),e.default='<p>컴파일 절차를 커스터마이즈 하기 위해 다양한 인터페이스를 사용할 수 있습니다. 인터페이스 간에 겹치는 기능도 존재합니다. 예를 들면, 구성 옵션은 CLI 플래그를 통해 사용할 수 있지만 다른 옵션은 단일 인터페이스를 통해서만 존재합니다. 아래의 정보가 시작하는 데 도움을 줄 것입니다.</p> <h2 id="cli">CLI<a href="#cli" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <p>명령 줄 인터페이스(CLI)는 빌드를 구성하고 상호작용하는 데 사용됩니다. 특히 초기 프로토타이핑이나 프로파일링의 경우 유용합니다. 대부분의 경우 CLI는 설정 파일과 <code>--env</code> 같은 몇 가지 플래그를 사용하여 프로세스를 시작하는 데 사용됩니다.</p> <p><a href="/api/cli">CLI에 대해 더 알아보세요!</a></p> <h2 id="module">Module<a href="#module" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <p>webpack을 사용하여 모듈을 처리할 때 <a href="/api/module-methods">메서드</a>나 <a href="/api/module-variables">변수</a>같이 다양한 지원되는 모듈 구문을 이해하는 것이 중요합니다.</p> <p><a href="/api/module-methods">모듈에 대해 더 알아보세요!</a></p> <h2 id="node">Node<a href="#node" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <p>대부분의 사용자는 설정 파일과 CLI를 함께 사용하는 것만으로도 충분하지만, Node 인터페이스를 통해 컴파일을 보다 세밀하게 제어할 수 있습니다. 여기에는 다중 설정 전달과 프로그래밍 방식으로 실행 또는 감시, 통계 수집이 포함됩니다.</p> <p><a href="/api/node">Node API에 대해 더 알아보세요!</a></p> <h2 id="loaders">Loaders<a href="#loaders" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <p>로더는 모듈의 소스 코드에 적용되는 변환입니다. 소스 코드를 매개 변수로 받고 변환이 적용된 해당 코드의 새 버전을 반환하는 함수로 작성됩니다.</p> <p><a href="/api/loaders">로더에 대해 더 알아보세요!</a></p> <h2 id="plugins">Plugins<a href="#plugins" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <p>플러그인 인터페이스를 통해 컴파일 프로세스에 직접 접근할 수 있습니다. 플러그인은 컴파일 동안 서로 다른 지점에서 실행되는 수명주기 훅에 핸들러를 등록할 수 있습니다. 각각의 훅이 실행될 때 플러그인은 현재 컴파일 상태에 대한 모든 액세스 권한을 갖습니다.</p> <p><a href="/api/plugins">플러그인에 대해 더 알아보세요!</a></p> '}}]);