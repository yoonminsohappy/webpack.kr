"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[2040],{2040:function(n,s,a){a.r(s),s.default='<p><em>Tree shaking은</em> 사용되지 않는 코드를 제거하기 위해 JavaScript 컨텍스트에서 일반적으로 사용되는 용어입니다. ES2015 모듈 구문은 <a href="http://exploringjs.com/es6/ch_modules.html#static-module-structure">정적 구조</a>에 의존합니다. 예를 들면, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import"><code>import</code></a>와 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export"><code>export</code></a>가 있습니다. 이름과 개념은 ES2015 모듈 번들러의 <a href="https://github.com/rollup/rollup">rollup</a>에 의해 대중화되었습니다.</p> <p>webpack 2 릴리스에서는 ES2015 모듈(별칭 <em>harmony 모듈</em>)과 사용하지 않는 모듈의 export를 감지하는 기능을 제공합니다. 새로운 webpack 4의 릴리스는 <code>package.json</code>의 <code>"sideEffects"</code> 프로퍼티를 통해 컴파일러에 힌트를 제공하는 방식으로 기능을 확장합니다. 프로젝트의 어떤 파일이 "순수"한지 나타내며, 만약 사용하지 않는다면 제거해도 괜찮은지 표시합니다.</p> <aside class="tip"><h6 class="tip__prefix">tip</h6><p>이 가이드의 나머지 부분은 <a href="/guides/getting-started">Getting Started에서</a> 시작합니다. 가이드를 아직 읽지 않았다면 지금 읽어보세요.</p></aside> <h2 id="add-a-utility">Add a Utility<a href="#add-a-utility" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <p>다음 두 함수를 내보내는 새 유틸리티 파일인 <code>src/math.js</code>를 프로젝트에 추가해 보겠습니다.</p> <p><strong>project</strong></p> <pre><code class="hljs language-diff">webpack-demo\n|- package.json\n|- webpack.config.js\n|- /dist\n<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> |- bundle.js\n</span><span class="token prefix unchanged"> </span><span class="token line"> |- index.html\n</span></span>|- /src\n<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> |- index.js\n</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"> |- math.js\n</span></span>|- /node_modules</code></pre> <p><strong>src/math.js</strong></p> <pre><code class="hljs language-javascript"><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">square</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> x <span class="token operator">*</span> x<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">cube</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> x <span class="token operator">*</span> x <span class="token operator">*</span> x<span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code></pre> <p><code>mode</code> 옵션을 <a href="/configuration/mode/#mode-development">development</a>로 설정하여 번들이 압축되지 않도록 합니다.</p> <p><strong>webpack.config.js</strong></p> <pre><code class="hljs language-diff">const path = require(\'path\');\n\nmodule.exports = {\n<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> entry: \'./src/index.js\',\n</span><span class="token prefix unchanged"> </span><span class="token line"> output: {\n</span><span class="token prefix unchanged"> </span><span class="token line">   filename: \'bundle.js\',\n</span><span class="token prefix unchanged"> </span><span class="token line">   path: path.resolve(__dirname, \'dist\'),\n</span><span class="token prefix unchanged"> </span><span class="token line"> },\n</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"> mode: \'development\',\n</span><span class="token prefix inserted">+</span><span class="token line"> optimization: {\n</span><span class="token prefix inserted">+</span><span class="token line">   usedExports: true,\n</span><span class="token prefix inserted">+</span><span class="token line"> },\n</span></span>};</code></pre> <p>이를 통해 새로운 메소드 중 하나를 사용하도록 entry 스크립트를 업데이트하고, 스크립트를 간단하게 하기 위해 <code>lodash</code>를 삭제하겠습니다.</p> <p><strong>src/index.js</strong></p> <pre><code class="hljs language-diff"><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line"> import _ from \'lodash\';\n</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"> import { cube } from \'./math.js\';\n</span></span>\n<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> function component() {\n</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">   const element = document.createElement(\'div\');\n</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">   const element = document.createElement(\'pre\');\n</span></span>\n<span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">   // 이제 Lodash를 스크립트로 가져왔습니다.\n</span><span class="token prefix deleted">-</span><span class="token line">   element.innerHTML = _.join([\'Hello\', \'webpack\'], \' \');\n</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">   element.innerHTML = [\n</span><span class="token prefix inserted">+</span><span class="token line">     \'Hello webpack!\',\n</span><span class="token prefix inserted">+</span><span class="token line">     \'5 cubed is equal to \' + cube(5)\n</span><span class="token prefix inserted">+</span><span class="token line">   ].join(\'\\n\\n\');\n</span></span>\n<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">   return element;\n</span><span class="token prefix unchanged"> </span><span class="token line"> }\n</span></span>\n<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> document.body.appendChild(component());</span></span></code></pre> <p>우리는 <code>src/math.js</code> 모듈에서 <strong><code>square</code> 메소드를 <code>가져오지</code> 않았습니다</strong>. 이 함수는 "사용하지 않는 코드"로 알려져 있고, 사용하지 않아 삭제되어야 하는 <code>export</code>를 의미합니다. 이제 npm 스크립트인 <code>npm run build</code>를 실행하여 출력된 번들을 살펴보겠습니다.</p> <p><strong>dist/bundle.js (around lines 90 - 100)</strong></p> <pre><code class="hljs language-js"><span class="token comment">/* 1 */</span>\n<span class="token comment">/***/</span> <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">module<span class="token punctuation">,</span> __webpack_exports__<span class="token punctuation">,</span> __webpack_require__</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token string">\'use strict\'</span><span class="token punctuation">;</span>\n  <span class="token comment">/* unused harmony export square */</span>\n  <span class="token comment">/* harmony export (immutable) */</span> __webpack_exports__<span class="token punctuation">[</span><span class="token string">\'a\'</span><span class="token punctuation">]</span> <span class="token operator">=</span> cube<span class="token punctuation">;</span>\n  <span class="token keyword">function</span> <span class="token function">square</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> x <span class="token operator">*</span> x<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token keyword">function</span> <span class="token function">cube</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> x <span class="token operator">*</span> x <span class="token operator">*</span> x<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> <p>위의 <code>unused harmony export square</code> 주석을 참고하세요. 아래 코드를 보면 <code>square</code>를 가져오지 않지만, 여전히 번들에 포함되어 있습니다. 다음 섹션에서 수정해 보겠습니다.</p> <h2 id="mark-the-file-as-side-effect-free">Mark the file as side-effect-free<a href="#mark-the-file-as-side-effect-free" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <p>100% ESM 모듈에서는 사이드 이펙트를 쉽게 식별할 수 있습니다. 그러나 우리는 아직 거기까지는 도달하지 않았으므로, 도달하기 까지는 코드의 "순수성"에 대한 힌트를 webpack 컴파일러에 제공해야 합니다.</p> <p>이를 수행하는 방법은 package.json의 <code>"sideEffects"</code> 속성입니다.</p> <pre><code class="hljs language-json"><span class="token punctuation">{</span>\n  <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"your-project"</span><span class="token punctuation">,</span>\n  <span class="token property">"sideEffects"</span><span class="token operator">:</span> <span class="token boolean">false</span>\n<span class="token punctuation">}</span></code></pre> <p>위에 언급한 코드는 사이드 이펙트를 포함하지 않으므로, 간단하게 <code>false</code>로 프로퍼티를 표시하여 사용하지 않는 export는 제거해도 괜찮다는 것을 webpack에 알릴 수 있습니다.</p> <aside class="tip"><h6 class="tip__prefix">tip</h6><p>"사이드 이펙트"는 하나 이상의 export를 보여주는 것 이외에도 import할 때 특별한 동작을 수행하는 코드입니다. 예를 들면 폴리필이 있습니다. 폴리필은 전체 스코프에 영향을 미치며 일반적으로 export를 제공하지 않습니다.</p></aside> <p>코드에 사이드 이펙트가 있다면 대신 배열을 사용할 수 있습니다.</p> <pre><code class="hljs language-json"><span class="token punctuation">{</span>\n  <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"your-project"</span><span class="token punctuation">,</span>\n  <span class="token property">"sideEffects"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"./src/some-side-effectful-file.js"</span><span class="token punctuation">]</span>\n<span class="token punctuation">}</span></code></pre> <p>배열은 관련된 파일의 간단한 전역 패턴을 허용합니다. 내부적으로 <a href="https://github.com/fitzgen/glob-to-regexp">glob-to-regexp</a>을 사용합니다 (사용 가능: <code>*</code>, <code>**</code>, <code>{a,b}</code>, <code>[a-z]</code>). <code>/</code>을 포함하지 않는 <code>*.css</code>와 같은 패턴은 <code>**/*.css</code>처럼 취급합니다.</p> <aside class="tip"><h6 class="tip__prefix">tip</h6><p>가져온 파일은 tree shaking의 대상이 됩니다. 즉, 프로젝트에서 CSS 파일을 가져오기 위해 <code>css-loader</code> 같은 것을 사용하는 경우 side effect 목록에 추가해야 프로덕션 모드에서 실수로 삭제되는 것을 방지할 수 있습니다.</p></aside> <pre><code class="hljs language-json"><span class="token punctuation">{</span>\n  <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"your-project"</span><span class="token punctuation">,</span>\n  <span class="token property">"sideEffects"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"./src/some-side-effectful-file.js"</span><span class="token punctuation">,</span> <span class="token string">"*.css"</span><span class="token punctuation">]</span>\n<span class="token punctuation">}</span></code></pre> <p>마지막으로 <code>"sideEffects"</code>는 <a href="https://webpack.js.org/configuration/module/#modulerules"><code>module.rules</code> 옵션</a>으로도 설정할 수 있습니다.</p> <h2 id="clarifying-tree-shaking-and-sideeffects">Clarifying tree shaking and <code>sideEffects</code><a href="#clarifying-tree-shaking-and-sideeffects" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <p><a href="/configuration/optimization/#optimizationsideeffects"><code>sideEffects</code></a>와 <a href="/configuration/optimization/#optimizationusedexports"><code>usedExports</code></a>(트리 쉐이킹으로 알려져 있음)의 최적화는 두 가지 다른 점이 있습니다.</p> <p><strong><code>sideEffects</code>는</strong> 전체 모듈 및 파일, 전체 하위 트리를 건너뛸 수 있기 때문에 <strong>훨씬 더 효율적입니다.</strong></p> <p><code>usedExports</code>는 <a href="https://github.com/terser-js/terser">terser</a>를 사용하여 문장에서 사이드 이펙트를 감지합니다. 이것은 JavaScript에서 어려운 작업이며 간단한 <code>sideEffects</code> 플래그만큼 효과적이지 않습니다. 또한 사이드 이펙트를 확인해야 하는 명세가 있기 때문에 하위트리 및 의존성을 무시할 수 없습니다. export 기능은 잘 동작하지만, React의 Higher Order Components(HOC)는 이와 관련된 문제가 있습니다.</p> <p>예를 들어보겠습니다.</p> <pre><code class="hljs language-javascript"><span class="token keyword">import</span> <span class="token punctuation">{</span> Button <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">\'@shopify/polaris\'</span><span class="token punctuation">;</span></code></pre> <p>미리 번들된 버전은 아래와 같습니다.</p> <pre><code class="hljs language-javascript"><span class="token keyword">import</span> hoistStatics <span class="token keyword">from</span> <span class="token string">\'hoist-non-react-statics\'</span><span class="token punctuation">;</span>\n\n<span class="token keyword">function</span> <span class="token function">Button</span><span class="token punctuation">(</span><span class="token parameter">_ref</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// ...</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">function</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">var</span> _final <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n  <span class="token keyword">for</span> <span class="token punctuation">(</span>\n    <span class="token keyword">var</span> _len <span class="token operator">=</span> arguments<span class="token punctuation">.</span>length<span class="token punctuation">,</span> objs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>_len<span class="token punctuation">)</span><span class="token punctuation">,</span> _key <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n    _key <span class="token operator">&#x3C;</span> _len<span class="token punctuation">;</span>\n    _key<span class="token operator">++</span>\n  <span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    objs<span class="token punctuation">[</span>_key<span class="token punctuation">]</span> <span class="token operator">=</span> arguments<span class="token punctuation">[</span>_key<span class="token punctuation">]</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> _i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> _objs <span class="token operator">=</span> objs<span class="token punctuation">;</span> _i <span class="token operator">&#x3C;</span> _objs<span class="token punctuation">.</span>length<span class="token punctuation">;</span> _i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">var</span> obj <span class="token operator">=</span> _objs<span class="token punctuation">[</span>_i<span class="token punctuation">]</span><span class="token punctuation">;</span>\n    <span class="token function">mergeRecursively</span><span class="token punctuation">(</span>_final<span class="token punctuation">,</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token keyword">return</span> _final<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">function</span> <span class="token function">withAppProvider</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">addProvider</span><span class="token punctuation">(</span><span class="token parameter">WrappedComponent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">var</span> WithProvider <span class="token operator">=</span>\n      <span class="token comment">/*#__PURE__*/</span>\n      <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">_React$Component</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// ...</span>\n        <span class="token keyword">return</span> WithProvider<span class="token punctuation">;</span>\n      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>Component<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    WithProvider<span class="token punctuation">.</span>contextTypes <span class="token operator">=</span> WrappedComponent<span class="token punctuation">.</span>contextTypes\n      <span class="token operator">?</span> <span class="token function">merge</span><span class="token punctuation">(</span>WrappedComponent<span class="token punctuation">.</span>contextTypes<span class="token punctuation">,</span> polarisAppProviderContextTypes<span class="token punctuation">)</span>\n      <span class="token operator">:</span> polarisAppProviderContextTypes<span class="token punctuation">;</span>\n    <span class="token keyword">var</span> FinalComponent <span class="token operator">=</span> <span class="token function">hoistStatics</span><span class="token punctuation">(</span>WithProvider<span class="token punctuation">,</span> WrappedComponent<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">return</span> FinalComponent<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">var</span> Button$<span class="token number">1</span> <span class="token operator">=</span> <span class="token function">withAppProvider</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>Button<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token keyword">export</span> <span class="token punctuation">{</span>\n  <span class="token comment">// ...,</span>\n  Button$<span class="token number">1</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre> <p><code>Button</code>이 사용되지 않으면 <code>export { Button$1 };</code>을 효과적으로 제거하고 나머지 코드를 모두 남길 수 있습니다. "이 코드가 사이드 이펙트가 없거나 안전하게 삭제할 수 있을까요?"라는 질문을 할 수 있습니다. <code>withAppProvider()(Button)</code> 라인 때문에 말하기 어렵습니다. <code>withAppProvider</code>가 호출되고 리턴 값도 호출됩니다. <code>merge</code> 또는 <code>hoistStatics</code>를 호출할 때 사이드 이펙트가 있나요? <code>WrappedComponent.contextTypes</code> (Getter?)를 읽거나 <code>WithProvider.contextTypes</code> (Setter?)를 할당할 때 사이드 이펙트가 있나요?</p> <p>Terser는 알아내려고 노력하지만 여러 상황에서 장담할 수는 없습니다. 이것은 terser가 알아낼 수 없기 때문에, terser가 역할을 잘 수행하지 못한다는 것이 아닙니다. JavaScript 같은 동적 언어에서 확실하게 판단하는 것은 매우 어렵습니다.</p> <p>그러나 <code>/*#__PURE__*/</code> 어노테이션을 이용하여 terser를 도와줄 수 있습니다. 그 구문은 사이드 이펙트가 없는 것으로 표시합니다. 그래서 간단한 변경만으로 코드를 tree-shake 할 수 있습니다.</p> <pre><code class="hljs language-javascript"><span class="token keyword">var</span> Button$<span class="token number">1</span> <span class="token operator">=</span> <span class="token comment">/*#__PURE__*/</span> <span class="token function">withAppProvider</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>Button<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> <p>이렇게 하면 이 코드를 제거 할 수 있습니다. 그러나 포함되어야 하거나 평가가 필요한 import는 사이드 이펙트가 있을 수 있기 때문에 여전히 이에 대한 문제가 남아 있습니다.</p> <p>이 문제를 해결하기 위해 <code>package.json</code>의 <a href="/guides/tree-shaking/#mark-the-file-as-side-effect-free"><code>"sideEffects"</code></a> 프로퍼티를 사용합니다.</p> <p>이것은 <code>/*#__PURE__*/</code>와 비슷하지만, 구문 레벨이 아닌 모듈 레벨에서 사용합니다. <code>"sideEffects"</code> 프로퍼티에 대해 "sideEffect가 없다고 플래그된 모듈에서 직접적인 export가 없는 경우 번들러는 사이드 이펙트에 대한 평가를 건너 뛸 수 있다."라고 설명하고 있습니다.</p> <p>Shopify\'s Polaris 예시에서 원래 모듈은 다음과 같습니다.</p> <p><strong>index.js</strong></p> <pre><code class="hljs language-javascript"><span class="token keyword">import</span> <span class="token string">\'./configure\'</span><span class="token punctuation">;</span>\n<span class="token keyword">export</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token string">\'./types\'</span><span class="token punctuation">;</span>\n<span class="token keyword">export</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token string">\'./components\'</span><span class="token punctuation">;</span></code></pre> <p><strong>components/index.js</strong></p> <pre><code class="hljs language-javascript"><span class="token comment">// ...</span>\n<span class="token keyword">export</span> <span class="token punctuation">{</span> <span class="token keyword">default</span> <span class="token keyword">as</span> Breadcrumbs <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">\'./Breadcrumbs\'</span><span class="token punctuation">;</span>\n<span class="token keyword">export</span> <span class="token punctuation">{</span> <span class="token keyword">default</span> <span class="token keyword">as</span> Button<span class="token punctuation">,</span> buttonFrom<span class="token punctuation">,</span> buttonsFrom <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">\'./Button\'</span><span class="token punctuation">;</span>\n<span class="token keyword">export</span> <span class="token punctuation">{</span> <span class="token keyword">default</span> <span class="token keyword">as</span> ButtonGroup <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">\'./ButtonGroup\'</span><span class="token punctuation">;</span>\n<span class="token comment">// ...</span></code></pre> <p><strong>package.json</strong></p> <pre><code class="hljs language-json"><span class="token comment">// ...</span>\n<span class="token property">"sideEffects"</span><span class="token operator">:</span> <span class="token punctuation">[</span>\n  <span class="token string">"**/*.css"</span><span class="token punctuation">,</span>\n  <span class="token string">"**/*.scss"</span><span class="token punctuation">,</span>\n  <span class="token string">"./esnext/index.js"</span><span class="token punctuation">,</span>\n  <span class="token string">"./esnext/configure.js"</span>\n<span class="token punctuation">]</span><span class="token punctuation">,</span>\n<span class="token comment">// ...</span></code></pre> <p><code>import { Button } from "@shopify/polaris";</code>는 다음과 같이 동작합니다.</p> <ul> <li>포함: 모듈을 포함하고 평가하며 계속 의존성을 분석합니다.</li> <li>건너뛰기: 포함하지 않으며 평가하지 않으나 계속 의존성을 평가합니다.</li> <li>제외: 포함하지 않으며 평가하지 않고 의존성도 분석하지 않습니다.</li> </ul> <p>매칭되는 리소스별로 자세히 보겠습니다.</p> <ul> <li><code>index.js</code>: 직접 export하여 사용하진 않지만 sideEffect의 플래그는 사용 -> 포함</li> <li><code>configure.js</code>: export하여 사용되지 않지만 sideEffect의 플래그는 사용 -> 포함</li> <li><code>types/index.js</code>: export하여 사용되지 않고 sideEffect로 플래그도 사용하지 않음 -> 제외</li> <li><code>components/index.js</code>: 직접 export하여 사용하지 않고 sideEffect로 플래그도 사용하지 않음, 그러나 다시 export한 export는 사용됨 -> 건너 뜀</li> <li><code>components/Breadcrumbs.js</code>: export하여 사용되지 않고 sideEffect로 플래그도 사용하지 않음 -> 제외 sideEffect 플래그가 있더라도 <code>components/Breadcrumbs.css</code>와 같은 모든 의존성은 제외됩니다.</li> <li><code>components/Button.js</code>: 직접 export를 사용하고 sideEffect 플래그는 사용하지 않음 -> 포함</li> <li><code>components/Button.css</code>: 직접 export를 사용하지 않지만 sideEffect 플래그는 사용함 ->포함</li> </ul> <p>위의 경우에 4개 모듈만 번들에 포함됩니다.</p> <ul> <li><code>index.js</code>: 거의 없음</li> <li><code>configure.js</code></li> <li><code>components/Button.js</code></li> <li><code>components/Button.css</code></li> </ul> <p>이 최적화 후, 다른 최적화도 적용할 수 있습니다. 예를 들면, <code>buttonFrom</code>과 <code>Button.js</code>에서 export하는 <code>buttonsFrom</code>은 사용되지 않습니다. <code>usedExports</code> 최적화는 이를 알아채고 terser는 모듈에서 일부 명령문을 삭제할 수 있습니다.</p> <p>모듈의 연결에도 적용됩니다. 따라서 이 4개의 모듈과 엔트리 모듈(그리고 아마도 좀 더 많은 의존성)을 연결할 수 있습니다. <strong>결국 <code>index.js</code>에는 생성되는 코드가 없습니다.</strong></p> <h2 id="mark-a-function-call-as-side-effect-free">Mark a function call as side-effect-free<a href="#mark-a-function-call-as-side-effect-free" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <p><code>/*#__PURE__*/</code>어노테이션을 사용하여 해당 함수 호출이 사이드 이펙트가 없다(side-effect-free)(순수하다)는 것을 webpack에 알릴 수 있습니다. 함수 호출 앞에 추가하여 사이드 이펙트가 없는 것으로 표시할 수 있습니다. 함수에 전달된 인수는 어노테이션으로 표시되지 않고 개별적으로 표시해야 할 수 있습니다. 사용하지 않는 변수의 초기값이 사이드 이펙트가 없다(순수하다)면, 사용하지 않는 코드로 표시되고 실행되지 않으며 최소화할 때 삭제됩니다. 이런 동작은 <a href="/configuration/optimization/#optimizationinnergraph"><code>optimization.innerGraph</code></a>가 <code>true</code> 일 때 활성화됩니다.</p> <p><strong>file.js</strong></p> <pre><code class="hljs language-javascript"><span class="token comment">/*#__PURE__*/</span> <span class="token function">double</span><span class="token punctuation">(</span><span class="token number">55</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> <h2 id="minify-the-output">Minify the Output<a href="#minify-the-output" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <p><code>import</code>와 <code>export</code> 구문을 통해 "사용하지 않는 코드"를 삭제했습니다. 하지만 번들에서도 삭제해야 합니다. 이렇게 하려면 <code>mode</code> 옵션을 <a href="/configuration/mode/#mode-production"><code>production</code></a>으로 설정해야 합니다.</p> <p><strong>webpack.config.js</strong></p> <pre><code class="hljs language-diff">const path = require(\'path\');\n\nmodule.exports = {\n<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> entry: \'./src/index.js\',\n</span><span class="token prefix unchanged"> </span><span class="token line"> output: {\n</span><span class="token prefix unchanged"> </span><span class="token line">   filename: \'bundle.js\',\n</span><span class="token prefix unchanged"> </span><span class="token line">   path: path.resolve(__dirname, \'dist\'),\n</span><span class="token prefix unchanged"> </span><span class="token line"> },\n</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line"> mode: \'development\',\n</span><span class="token prefix deleted">-</span><span class="token line"> optimization: {\n</span><span class="token prefix deleted">-</span><span class="token line">   usedExports: true,\n</span><span class="token prefix deleted">-</span><span class="token line"> }\n</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"> mode: \'production\',\n</span></span>};</code></pre> <aside class="tip"><h6 class="tip__prefix">tip</h6><p><code>--optimize-minimize</code> 플래그를 사용하여 <code>TerserPlugin</code>도 활성화 할 수 있습니다.</p></aside> <p>즉, 다른 <code>npm run build</code>를 실행하고 변경된 사항이 있는지 볼 수 있습니다.</p> <p><code>dist/bundle.js</code>에서 다른 점을 찾았나요? 정확하게 전체 번들이 최소화되고 난독화 되었지만, 자세히 보면 포함되어 있던 <code>square</code> 함수가 없으며 난독화 된 <code>cube</code> 함수 (<code>function r(e){return e*e*e}n.a=r</code>)를 볼 수 있습니다. 최소화와 tree shaking으로 번들은 이제 몇 바이트 더 작아졌습니다! 위의 임의로 만든 예제에서는 큰 변화를 느끼지 못하겠지만 tree shaking은 복잡한 의존성 트리가 있는 커다란 애플리케이션에서 작업할 때 번들의 크기를 많이 줄일 수 있습니다.</p> <aside class="tip"><h6 class="tip__prefix">tip</h6><p><a href="/plugins/module-concatenation-plugin/"><code>ModuleConcatenationPlugin</code></a>은 tree shaking이 동작하기 위해 필요합니다. <code>mode: \'production\'</code>에 의해 추가됩니다. 만약 사용하지 않는다면, <a href="/plugins/module-concatenation-plugin/"><code>ModuleConcatenationPlugin</code></a>을 수동으로 추가해야 합니다.</p></aside> <h2 id="conclusion">Conclusion<a href="#conclusion" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <p>그래서 <em>tree shaking의</em> 이점을 살리기 위하여</p> <ul> <li>ES2015 모듈 구문을 사용해야 하는 것을 배웠습니다. (예: <code>import</code>와 <code>export</code>)</li> <li>컴파일러가 ES2015 모듈 구문을 CommonJS 모듈로 변환하지 않도록 해야 합니다. (이것은 인기 있는 Babel preset @babel/preset-env의 기본 동작입니다. 자세한 내용은 <a href="https://babeljs.io/docs/en/babel-preset-env#modules">documentation</a>를 참고하세요.)</li> <li><code>package.json</code> 파일에 <code>"sideEffects"</code> 속성을 추가하세요.</li> <li>최소화와 tree shaking을 포함한 <a href="/configuration/mode/#usage">다양한 최적화를</a> 사용하려면 <a href="/configuration/mode/#mode-production"><code>production</code></a> <code>mode</code> 설정 옵션을 사용하세요.</li> </ul> <p>애플리케이션을 나무와 같이 생각할 수 있습니다. 실제로 사용되는 소스 코드와 라이브러리는 나무의 살아있는 잎과 같은 녹색을 나타냅니다. 사용하지 않는 코드는 가을에 바싹 마른 나무의 죽은 잎사귀처럼 갈색입니다. 낙엽을 없애기 위해서 나무를 흔들어서 낙엽을 떨어 뜨려야 합니다.</p> <p>산출물에 대한 최적화에 더 관심이 있다면 <a href="/guides/production">production</a>을 빌드하기 위한 상세 가이드로 이동하세요.</p> '}}]);